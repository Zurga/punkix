# Monkey Patching - Elixir Meetup

```elixir
Mix.install([{:msgpax, "~> 2.4.0"}, {:punkix, path: "~/git/punkix"}, {:beam_file, "~> 0.6.0"}])
require IEx.Helpers
import IEx.Helpers
```

## Motivation and background

### About my programming style:

* #### KISS DRY
* #### Reuse code whenever possible
* #### Abstract functionality until it hurts

There is probably some tension in this list.

<!-- livebook:{"break_markdown":true} -->

### Phoenix has been my entrypoint into Elixir.

### Recently, it has taken a path I don't want to follow.

### I don't like Tailwind.

<!-- livebook:{"break_markdown":true} -->

### So, what do I want?

* #### Surface for the LiveView stuff
* #### Seperate modules defining MyAppWeb.{Component, LiveComponent, LiveView, FormComponent, etc...}
* #### Ecto `embedded_schema` as FormComponent backend
* #### More responsibility for the FormComponents
* #### Schema validations in context modules, inspired by Very Big Things medium posts
* #### Schemas in a `lib/schemas/#{Context}` folder
* #### Credo, TypedEctoSchema, Boundary listed as dependencies
* #### LiveView tests written with Skipper
* #### Use MsgPack as default for LiveSocket

<!-- livebook:{"break_markdown":true} -->

### Option 1: fork the Phoenix project and rewrite the installer templates to fit my needs.

### Option 2: Rewrite all the code generated by the Phoenix generators each time I use one.

<!-- livebook:{"break_markdown":true} -->

### Option 1:

#### Advantages:

* ##### full control

#### Disadvantages:

* ##### takes a lot of time
* ##### hard to integrate changes made upstream

<!-- livebook:{"break_markdown":true} -->

### Option 2:

#### Advantages:

* ##### use changes from upstream automatically

#### Disadvantages:

* ##### takes a lot of time, every time.

<!-- livebook:{"break_markdown":true} -->

### After starting the work with Option 1, I realised that the generators allow for custom templates to be used.

## A third option appears

```elixir
# Option 3
h(Mix.Phoenix.generator_paths())
```

Previous work:

* meta

## What to do about private functions called in public functions?

```elixir
# How can we reuse the hello/0 function and but 
# have it output "Hello Mars!"?

defmodule Greet do
  def hello(), do: "Hello #{planet()}!"
  defp planet(), do: "World"
end
```

```elixir
defmodule GreetMars do
  use Punkix.Patcher
  replace(Greet, :planet, 0, :mars)

  def hello(), do: patched(Greet).hello()
  def mars(), do: "Mars"
end

GreetMars.hello()
```

## Section

```elixir
BeamFile.abstract_code!(GreetMars)
```
